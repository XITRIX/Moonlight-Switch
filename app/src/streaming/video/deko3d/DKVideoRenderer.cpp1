#if defined(__SWITCH__) && defined(BOREALIS_USE_DEKO3D)

#include "DKVideoRenderer.hpp"

#include <cstdint>
#include <array>
#include <borealis.hpp>
#include <borealis/platforms/switch/switch_platform.hpp>

#define GLM_FORCE_DEFAULT_ALIGNED_GENTYPES
#define GLM_FORCE_INTRINSICS
#include <glm/matrix.hpp>

#include <libavcodec/avcodec.h>
#include <libavutil/hwcontext_tx1.h>

/* Generated from:
#version 460

in vec2 vertex_position;

in vec2 vertex_texcoord0;
out vec2 texcoord0;
in vec2 vertex_texcoord1;
out vec2 texcoord1;

void main() {
    gl_Position = vec4(vertex_position, 1.0, 1.0);
    gl_Position.y = -gl_Position.y;
    texcoord0 = vertex_texcoord0;
    texcoord1 = vertex_texcoord1;
}
*/

constexpr static std::array<std::uint8_t, 0x100> vert_sh_control = {
    0x44, 0x4b, 0x53, 0x48, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

constexpr static std::array<std::uint8_t, 0x100> vert_sh_code = {
    0x6c, 0x6f, 0x6c, 0x20, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x20, 0x77, 0x68, 0x79, 0x20, 0x64,
    0x69, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x75, 0x73, 0x20, 0x77,
    0x61, 0x73, 0x74, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x68, 0x65, 0x72, 0x65, 0x00,
    0x61, 0x04, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x07, 0x00, 0xfe, 0x01, 0x3c, 0x1c, 0x00, 0x00, 0xff, 0x07, 0x08, 0x80, 0xff, 0xd8, 0xef,
    0x01, 0xff, 0x17, 0x00, 0x00, 0x30, 0x59, 0x5c, 0x02, 0xff, 0x07, 0x0a, 0x80, 0xff, 0xd8, 0xef,
    0xe2, 0x08, 0x20, 0xfc, 0x01, 0x98, 0x1f, 0x00, 0x02, 0xff, 0x07, 0x09, 0x80, 0xff, 0xf0, 0xef,
    0x02, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0x03, 0x01, 0x03, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0x03, 0x01,
    0xe2, 0x00, 0xe0, 0xe1, 0x01, 0x84, 0x23, 0x00, 0x00, 0xff, 0x07, 0x07, 0x80, 0xff, 0xf1, 0xef,
    0x00, 0xff, 0x07, 0x09, 0x80, 0xff, 0xd8, 0xef, 0x00, 0xff, 0x07, 0x08, 0x80, 0xff, 0xf0, 0xef,
    0xef, 0xff, 0xe1, 0xff, 0x00, 0x80, 0x1f, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe3,
    0x0f, 0x00, 0x87, 0xff, 0xff, 0x0f, 0x40, 0xe2, 0x00, 0x0f, 0x07, 0x00, 0x00, 0x00, 0xb0, 0x50,
};

/* Generated from:
#version 460

out vec4 out_color;

in vec2 texcoord0;
in vec2 texcoord1;

layout(std140, binding=0) uniform UBO {
    layout(offset= 0) mat3 colormatrix;
    layout(offset=48) vec3 colormatrix_c;
};

layout(binding=0) uniform sampler2D texture0;
layout(binding=1) uniform sampler2D texture1;

void main() {
    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
    color.r  = 1.000000 * vec4(texture(texture0, texcoord0)).r;
    color.gb = 1.000000 * vec4(texture(texture1, texcoord1)).rg;
    color = color.rgbr;
    color.rgb = mat3(colormatrix) * color.rgb + colormatrix_c;
    color.a = 1.0;
    out_color = color;
}
*/

constexpr static std::array<std::uint8_t, 0x100> frag_sh_control = {
    0x44, 0x4b, 0x53, 0x48, 0x18, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x18, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x60, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

constexpr static std::array<std::uint8_t, 0x200> frag_sh_code = {
    0x6c, 0x6f, 0x6c, 0x20, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x20, 0x77, 0x68, 0x79, 0x20, 0x64,
    0x69, 0x64, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6d, 0x61, 0x6b, 0x65, 0x20, 0x75, 0x73, 0x20, 0x77,
    0x61, 0x73, 0x74, 0x65, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x68, 0x65, 0x72, 0x65, 0x00,
    0x62, 0x54, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x80, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x07, 0xa0, 0xe1, 0x01, 0x04, 0x3c, 0x00, 0x00, 0xff, 0xf7, 0xcf, 0x87, 0xff, 0x03, 0xe0,
    0x00, 0x00, 0x47, 0x00, 0x00, 0x00, 0x80, 0x50, 0x01, 0xff, 0x07, 0x00, 0x88, 0xff, 0x43, 0xe0,
    0x2f, 0x07, 0x40, 0x20, 0x03, 0x88, 0x48, 0x00, 0x02, 0xff, 0x07, 0x40, 0x88, 0xff, 0x43, 0xe0,
    0x02, 0x01, 0x27, 0xf0, 0x4f, 0x1a, 0x20, 0xd8, 0x01, 0xff, 0x07, 0x00, 0x89, 0xff, 0x43, 0xe0,
    0x4f, 0x27, 0x20, 0xe4, 0x06, 0x84, 0x3f, 0x08, 0x00, 0xff, 0x07, 0x40, 0x89, 0xff, 0x43, 0xe0,
    0x00, 0x01, 0x07, 0xf0, 0x5f, 0x1a, 0x30, 0xd8, 0x03, 0x02, 0x07, 0x00, 0x08, 0x10, 0x68, 0x4c,
    0xe1, 0x07, 0x82, 0xfd, 0x00, 0x84, 0x5f, 0x08, 0x04, 0x02, 0x17, 0x00, 0x08, 0x10, 0x68, 0x4c,
    0x02, 0x02, 0x27, 0x00, 0x08, 0x10, 0x68, 0x4c, 0x03, 0x00, 0x47, 0x00, 0x88, 0x01, 0xa0, 0x49,
    0xe1, 0x07, 0x82, 0xfc, 0x00, 0x84, 0x1f, 0x08, 0x04, 0x00, 0x57, 0x00, 0x08, 0x02, 0xa0, 0x49,
    0x00, 0x00, 0x67, 0x00, 0x08, 0x01, 0xa0, 0x49, 0x02, 0x01, 0x87, 0x00, 0x88, 0x01, 0xa0, 0x49,
    0xe1, 0x07, 0x82, 0xfc, 0x00, 0x84, 0x1f, 0x00, 0x03, 0x01, 0x97, 0x00, 0x08, 0x02, 0xa0, 0x49,
    0x04, 0x01, 0xa7, 0x00, 0x08, 0x00, 0xa0, 0x49, 0x00, 0x02, 0xc7, 0x00, 0x08, 0x10, 0x58, 0x4c,
    0xe1, 0x07, 0x20, 0xfc, 0x00, 0xc0, 0x1f, 0x00, 0x01, 0x03, 0xd7, 0x00, 0x08, 0x10, 0x58, 0x4c,
    0x02, 0x04, 0xe7, 0x00, 0x08, 0x10, 0x58, 0x4c, 0x03, 0xf0, 0x07, 0x00, 0x00, 0xf8, 0x03, 0x01,
    0xef, 0xff, 0xe1, 0xff, 0x00, 0x80, 0x1f, 0x00, 0x0f, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0xe3,
    0x0f, 0x00, 0x87, 0xff, 0xff, 0x0f, 0x40, 0xe2, 0x00, 0x0f, 0x07, 0x00, 0x00, 0x00, 0xb0, 0x50,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

struct UniformBufferLayout {
    glm::mat3 colormatrix;
    glm::vec3 colormatrix_c;
    glm::vec4 uv;
};

struct VertexLayout {
    float vertex_position[2];
};

constexpr std::array vertices = {
    VertexLayout{ {-1.0f, -1.0f} },
    VertexLayout{ { 1.0f, -1.0f} },
    VertexLayout{ {-1.0f,  1.0f} },
    VertexLayout{ { 1.0f,  1.0f} },
};

constexpr std::array vertex_attrib_state = {
    DkVtxAttribState{ 0, 0, offsetof(VertexLayout, vertex_position), DkVtxAttribSize_2x32, DkVtxAttribType_Float, 0 },
};

constexpr std::array vertex_buffer_state = {
    DkVtxBufferState{ sizeof(VertexLayout), 0 },
};

constexpr std::size_t cmdbuf_size = 0x400;

/*
Memory layout:
    0x0000 Vertex shader
    0x0100 Fragment shader
    0x0300 Uniform buffer
    0x0340 Vertex buffer
    0x0360 Command buffer 1
    0x0760 Command buffer 2
    0x0b60 End
-> Total buffer size: 0x1000
*/

template <typename T, typename U>
constexpr T align_up(T v, U a) {
    return (v + a - 1) & ~(a - 1);
}

constexpr std::size_t vert_sh_offset  = 0;
constexpr std::size_t frag_sh_offset  = vert_sh_offset  + align_up(vert_sh_code.size(), DK_SHADER_CODE_ALIGNMENT);
constexpr std::size_t ubo_offset      = frag_sh_offset  + align_up(frag_sh_code.size(), DK_UNIFORM_BUF_ALIGNMENT);
constexpr std::size_t vbo_offset      = ubo_offset      + sizeof(UniformBufferLayout);
constexpr std::size_t cmdbuf_1_offset = vbo_offset      + align_up(sizeof(vertices),    DK_CMDMEM_ALIGNMENT);
constexpr std::size_t cmdbuf_2_offset = cmdbuf_1_offset + align_up(cmdbuf_size,         DK_CMDMEM_ALIGNMENT);

constexpr std::size_t memblock_size = align_up(cmdbuf_2_offset + align_up(cmdbuf_size, DK_CMDMEM_ALIGNMENT), DK_MEMBLOCK_ALIGNMENT);

DKVideoRenderer::DKVideoRenderer() {
    brls::Logger::info("{}", __PRETTY_FUNCTION__);
};

DKVideoRenderer::~DKVideoRenderer() {
    brls::Logger::info("{}", __PRETTY_FUNCTION__);

    this->queue.waitIdle();
}

void DKVideoRenderer::initialize() {
    brls::Logger::info("{}", __PRETTY_FUNCTION__);

    auto *vctx = (brls::SwitchVideoContext *)brls::Application::getPlatform()->getVideoContext();
    this->dev = vctx->getDeko3dDevice(), this->queue = vctx->getQueue();

    this->memblk = dk::MemBlockMaker{this->dev, memblock_size}
        .setFlags(DkMemBlockFlags_GpuUncached | DkMemBlockFlags_GpuCached | DkMemBlockFlags_Code)
        .create();

    auto *buf = static_cast<std::uint8_t *>(this->memblk.getCpuAddr());

    std::memcpy(buf + vert_sh_offset, vert_sh_code.data(), vert_sh_code.size());
    std::memcpy(buf + frag_sh_offset, frag_sh_code.data(), frag_sh_code.size());
    std::memcpy(buf + vbo_offset, vertices.data(), vertices.size());

    dk::ShaderMaker{this->memblk, vert_sh_offset}
        .setControl(vert_sh_control.data())
        .initialize(this->vert_sh);

    dk::ShaderMaker{this->memblk, frag_sh_offset}
        .setControl(frag_sh_control.data())
        .initialize(this->frag_sh);

    this->cmdbuf = dk::CmdBufMaker{this->dev}
        .create();

    sampler.setFilter(DkFilter_Linear, DkFilter_Linear);
    sampler.setWrapMode(DkWrapMode_ClampToEdge, DkWrapMode_ClampToEdge, DkWrapMode_ClampToEdge);

    samplerDescriptor.initialize(sampler);
    cmdbuf.pushData(this->memblk.getGpuAddr())
    samplerDescriptorSet.update(cmdbuf, 0, samplerDescriptor);
}

void DKVideoRenderer::checkAndInitialize(int width, int height, AVFrame* frame) {
    if (m_is_initialized)
        return;

    this->initialize();
    m_is_initialized = true;
}

void DKVideoRenderer::draw(NVGcontext* vg, int width, int height, AVFrame* frame) {
    this->checkAndInitialize(width, height, frame);

    this->cmdbuf.addMemory(this->memblk, cmdbuf_size * this->cmdbuf_slice, cmdbuf_size);
    ++this->cmdbuf_slice %= brls::FRAMEBUFFERS_COUNT;


    uint64_t before_render = LiGetMillis();
    if (!m_video_render_stats.rendered_frames) {
        m_video_render_stats.measurement_start_timestamp = before_render;
    }

    this->cmdbuf.clearColor(0, DkColorMask_RGBA, 0.0f, 1.0f, 0.0f, 1.0f);

    dk::RasterizerState rasterizerState;
    dk::ColorState colorState;
    dk::ColorWriteState colorWriteState;
    dk::DepthStencilState depthStencilState;

    auto buf = this->memblk.getGpuAddr();
    this->cmdbuf.bindShaders(DkStageFlag_GraphicsMask, { &this->vert_sh, &this->frag_sh });
    this->cmdbuf.bindUniformBuffer(DkStage_Fragment, 0, buf + ubo_offset, sizeof(UniformBufferLayout));
    this->cmdbuf.bindRasterizerState(rasterizerState);
    this->cmdbuf.bindColorState(colorState);
    this->cmdbuf.bindColorWriteState(colorWriteState);
    this->cmdbuf.bindDepthStencilState(depthStencilState);
    this->cmdbuf.bindVtxBuffer(0, buf + vbo_offset, sizeof(vertices));
    this->cmdbuf.bindVtxAttribState(vertex_attrib_state);
    this->cmdbuf.bindVtxBufferState(vertex_buffer_state);

    // Create layout for the texture
    // The important part is to use DkImageFlags_UsageVideo, 
    // which ensures a consistent texture layout between NVDEC and the GPU
    dk::ImageLayout layout; 
    dk::ImageLayoutMaker{this->dev}
        .setType(DkImageType_2D)
        .setFormat(DkImageFormat_R8_Unorm)
        .setDimensions(width, height, 1)
        .setFlags(DkImageFlags_UsageLoadStore | DkImageFlags_Usage2DEngine | DkImageFlags_UsageVideo)
        .initialize(layout);

    // Retrieve the CPU address of the decoded data,
    // and create a GPU mapping (memblock) over it
    // AVFrame *frame; // The frame returned by the hardware decoder
    AVTX1Map *map = ff_tx1_frame_get_fbuf_map(frame); 

    dk::MemBlock memblock = dk::MemBlockMaker{ dev, ff_tx1_map_get_size(map) }
    .setFlags(DkMemBlockFlags_CpuUncached |
        DkMemBlockFlags_GpuCached | DkMemBlockFlags_Image)
        .setStorage(ff_tx1_map_get_addr(map))
        .create();

    // Finally, create a texture over that memblock using the layout we calculated
    // DkImage image;
    // dkImageInitialize(&image, &layout, memblock, 0);

    dk::Image image;
    image.initialize(layout, memblock, 0);

    // Initialize image/sample descriptors as usual,
    // and invalidate the texture cache before use
    m_descriptor.initialize(image);

    // Deinitialization
    dkMemBlockDestroy(memblock);

    this->queue.submitCommands(this->cmdbuf.finishList());

    // Doesn't measure render time unless the queue is idle but whatever
    this->queue.waitIdle();
    m_video_render_stats.total_render_time += LiGetMillis() - before_render;
    m_video_render_stats.rendered_frames++;
}

VideoRenderStats* DKVideoRenderer::video_render_stats() {
    // brls::Logger::info("{}", __PRETTY_FUNCTION__);
    m_video_render_stats.rendered_fps =
        (float)m_video_render_stats.rendered_frames /
        ((float)(LiGetMillis() -
                 m_video_render_stats.measurement_start_timestamp) /
         1000);
    return &m_video_render_stats;
}

#endif // __SWITCH__